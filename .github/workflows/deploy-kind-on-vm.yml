name: Provision Kind Cluster on VM

on:
  workflow_dispatch:
    inputs:
      cluster_name:
        description: 'Name of the Kind cluster'
        required: true
        type: string
      vm_user:
        description: 'VM SSH username'
        required: true
        type: string
      vm_key:
        description: 'VM SSH private key'
        required: true
        type: string
      vm_host:
        description: 'VM IP address or hostname'
        required: true
        type: string

jobs:
  provision-kind-cluster:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Validate inputs
      run: |
        if [[ -z "${{ github.event.inputs.cluster_name }}" ]]; then
          echo "Error: cluster_name is required"
          exit 1
        fi
        if [[ -z "${{ github.event.inputs.vm_user }}" ]]; then
          echo "Error: vm_user is required"
          exit 1
        fi
        if [[ -z "${{ github.event.inputs.vm_host }}" ]]; then
          echo "Error: vm_host is required"
          exit 1
        fi
        # Validate cluster name format (alphanumeric and hyphens only)
        if [[ ! "${{ github.event.inputs.cluster_name }}" =~ ^[a-zA-Z0-9-]+$ ]]; then
          echo "Error: cluster_name must contain only alphanumeric characters and hyphens"
          exit 1
        fi
    
    - name: Install tweetsodium
      run: npm install tweetsodium

    # --- Ensure Environment Exists ---
    - name: Ensure GitHub Environment
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.AUTO_DEPLOY_TOKEN }}
        script: |
          const envName = `ENV_${{ github.event.inputs.cluster_name }}`;
          try {
            await github.rest.repos.getEnvironment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              environment_name: envName
            });
            console.log(`âœ… Environment ${envName} already exists`);
          } catch (error) {
            if (error.status === 404) {
              await github.rest.repos.createOrUpdateEnvironment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                environment_name: envName
              });
              console.log(`âœ… Created environment: ${envName}`);
            } else {
              throw error;
            }
          }

    - name: Create Environment Secrets
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.AUTO_DEPLOY_TOKEN }}
        script: |
          const vars = {
            CLUSTER_NAME: process.env.CLUSTER_NAME,
            VM_USER: process.env.VM_USER,
            VM_HOST: process.env.VM_HOST,
            VM_KEY: process.env.VM_KEY,
          };

          for (const [key, value] of Object.entries(vars)) {
            if (!value) {
              console.log(`âš ï¸ Skipping ${key}, value not provided`);
              continue;
            }
            console.log(`âž¡ï¸ Creating secret: ${key}`);
            await exec.exec('gh', [
              'secret', 'set', key,
              '--env', `ENV_${process.env.CLUSTER_NAME}`,
              '--body', value,
              '--repo', `${context.repo.owner}/${context.repo.repo}`
            ]);
          }
      env:
        CLUSTER_NAME: ${{ github.event.inputs.cluster_name }}
        VM_USER: ${{ github.event.inputs.vm_user }}
        VM_HOST: ${{ github.event.inputs.vm_host }}
        VM_KEY: ${{ github.event.inputs.vm_key }}


    - name: Set VM_USER Secret
      uses: gliech/create-github-secret-action@v1
      with:
        name: VM_USER
        value: ${{ github.event.inputs.vm_user }}
        location: env:ENV_${{ github.event.inputs.cluster_name }}
        pa_token: ${{ secrets.AUTO_DEPLOY_TOKEN }}

    - name: Set VM_HOST Secret
      uses: gliech/create-github-secret-action@v1
      with:
        name: VM_HOST
        value: ${{ github.event.inputs.vm_host }}
        location: env:ENV_${{ github.event.inputs.cluster_name }}
        pa_token: ${{ secrets.AUTO_DEPLOY_TOKEN }}

    - name: Set VM_KEY Secret
      uses: gliech/create-github-secret-action@v1
      with:
        name: VM_KEY
        value: ${{ github.event.inputs.vm_key }}
        location: env:ENV_${{ github.event.inputs.cluster_name }}
        pa_token: ${{ secrets.AUTO_DEPLOY_TOKEN }}


          

    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        
        # Create SSH key file using base64 to handle special characters
        echo '${{ github.event.inputs.vm_key }}' | base64 -d > ~/.ssh/vm_key 2>/dev/null || {
          # If base64 decode fails, treat as regular text
          cat << 'EOF' > ~/.ssh/vm_key
        ${{ github.event.inputs.vm_key }}
        EOF
        }
        
        # Ensure proper permissions
        chmod 600 ~/.ssh/vm_key
        
        # Debug: Show key format
        echo "SSH key file created. First few lines:"
        head -3 ~/.ssh/vm_key
        echo "Last few lines:"
        tail -3 ~/.ssh/vm_key
        
        # Verify key format
        echo "Verifying SSH key format..."
        if ssh-keygen -l -f ~/.ssh/vm_key; then
          echo "SSH key format is valid"
        else
          echo "SSH key format verification failed. Attempting to fix format..."
          
          # Try to fix common formatting issues
          temp_key=$(cat ~/.ssh/vm_key | tr -d '\r' | tr -s ' ' | sed 's/- /-/g')
          
          # Check if it contains the key headers
          if echo "$temp_key" | grep -q "BEGIN.*PRIVATE KEY"; then
            echo "$temp_key" > ~/.ssh/vm_key
            chmod 600 ~/.ssh/vm_key
            
            # Try verification again
            if ssh-keygen -l -f ~/.ssh/vm_key; then
              echo "SSH key format fixed and verified"
            else
              echo "Error: Could not fix SSH key format"
              echo "Please ensure your SSH private key is properly formatted"
              echo "Expected format example:"
              echo "-----BEGIN RSA PRIVATE KEY-----"
              echo "MIICXAIBAAKBgQC..."
              echo "-----END RSA PRIVATE KEY-----"
              exit 1
            fi
          else
            echo "Error: SSH key does not contain proper headers"
            exit 1
          fi
        fi
        
        # Add host to known_hosts
        ssh-keyscan -H ${{ github.event.inputs.vm_host }} >> ~/.ssh/known_hosts 2>/dev/null || echo "Warning: Could not add host to known_hosts"

    - name: Test SSH connection
      run: |
        echo "Testing SSH connection..."
        ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes ${{ github.event.inputs.vm_user }}@${{ github.event.inputs.vm_host }} "echo 'SSH connection successful'" || (
          echo "SSH connection failed. Debugging..."
          echo "SSH key fingerprint:"
          ssh-keygen -l -f ~/.ssh/vm_key
          echo "Attempting connection with verbose output:"
          ssh -v -i ~/.ssh/vm_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 ${{ github.event.inputs.vm_user }}@${{ github.event.inputs.vm_host }} "echo 'test'" 2>&1 | head -20
          exit 1
        )

    - name: Install dependencies on VM
      run: |
        ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 ${{ github.event.inputs.vm_user }}@${{ github.event.inputs.vm_host }} << 'EOF'
          set -e
          
          echo "Updating system packages..."
          sudo apt-get update -y
          
          # Install Docker if not already installed
          if ! command -v docker &> /dev/null; then
            echo "Installing Docker..."
            # Remove any old Docker packages
            sudo apt-get remove -y docker docker-engine docker.io containerd runc || true
            
            # Install prerequisites
            sudo apt-get install -y \
              ca-certificates \
              curl \
              gnupg \
              lsb-release
            
            # Add Docker's official GPG key
            sudo mkdir -p /etc/apt/keyrings
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            
            # Set up repository
            echo \
              "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
              $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            
            # Install Docker Engine
            sudo apt-get update -y
            sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
            
            # Add user to docker group
            sudo usermod -aG docker $USER
            
            # Enable and start Docker
            sudo systemctl enable docker
            sudo systemctl start docker
            
            # Wait for Docker to be ready
            sleep 5
            sudo docker version
          else
            echo "Docker is already installed"
            docker --version
          fi
          
          # Install kubectl if not already installed
          if ! command -v kubectl &> /dev/null; then
            echo "Installing kubectl..."
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
          else
            echo "kubectl is already installed"
          fi
          kubectl version --client
          
          # Install Kind if not already installed
          if ! command -v kind &> /dev/null; then
            echo "Installing Kind..."
            curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
            chmod +x ./kind
            sudo mv ./kind /usr/local/bin/kind
          else
            echo "Kind is already installed"
          fi
          kind version
          
          echo "All dependencies installed successfully"
        EOF

    - name: Create Kind cluster configuration
      run: |
        cat > kind-config.yaml << EOF
        kind: Cluster
        apiVersion: kind.x-k8s.io/v1alpha4
        name: ${{ github.event.inputs.cluster_name }}
        networking:
          apiServerAddress: "0.0.0.0"
          apiServerPort: 6443
        nodes:
        - role: control-plane
          kubeadmConfigPatches:
          - |
            kind: InitConfiguration
            nodeRegistration:
              kubeletExtraArgs:
                node-labels: "ingress-ready=true"
          - |
            kind: ClusterConfiguration
            apiServer:
              certSANs:
              - ${{ github.event.inputs.vm_host }}
              - "localhost"
              - "127.0.0.1"
          extraPortMappings:
          - containerPort: 80
            hostPort: 80
            protocol: TCP
          - containerPort: 443
            hostPort: 443
            protocol: TCP
          - containerPort: 6443
            hostPort: 16443
            protocol: TCP
        EOF

    - name: Copy Kind config to VM and create cluster
      run: |
        # Copy kind config to VM
        scp -i ~/.ssh/vm_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 kind-config.yaml ${{ github.event.inputs.vm_user }}@${{ github.event.inputs.vm_host }}:~/
        
        # Create Kind cluster on VM
        ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 ${{ github.event.inputs.vm_user }}@${{ github.event.inputs.vm_host }} << 'EOF'
          set -e
          
          # Check if cluster already exists
          if kind get clusters 2>/dev/null | grep -q "^${{ github.event.inputs.cluster_name }}$"; then
            echo "Cluster ${{ github.event.inputs.cluster_name }} already exists, deleting it first..."
            kind delete cluster --name ${{ github.event.inputs.cluster_name }} || true
            sleep 10
          fi
          
          echo "Creating Kind cluster: ${{ github.event.inputs.cluster_name }}"
          
          # Use newgrp to ensure docker group membership is active
          newgrp docker << 'DOCKER_EOF'
          kind create cluster --config kind-config.yaml --wait 300s
          echo "Cluster created successfully"
        DOCKER_EOF
        EOF

    - name: Get kubeconfig from VM
      run: |
        # Get kubeconfig from VM
        ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 ${{ github.event.inputs.vm_user }}@${{ github.event.inputs.vm_host }} "newgrp docker << 'DOCKER_EOF'
        kind get kubeconfig --name ${{ github.event.inputs.cluster_name }}
        DOCKER_EOF" > kubeconfig-temp.yaml


        # Modify kubeconfig to use VM's external IP
        sed -i "s/127.0.0.1/${{ github.event.inputs.vm_host }}/g" kubeconfig-temp.yaml
        sed -i "s/0.0.0.0/${{ github.event.inputs.vm_host }}/g" kubeconfig-temp.yaml
        
        
        echo "Modified kubeconfig to use external VM IP"
        echo "Kubeconfig content:"
        cat kubeconfig-temp.yaml

    - name: Test cluster connectivity
      run: |
        # kubectl cluster-info --context kind-${{ github.event.inputs.cluster_name }}
        export KUBECONFIG=./kubeconfig-temp.yaml
        kubectl cluster-info
        kubectl get nodes
        echo "Cluster is accessible from external network"
        


    - name: Set Environment Secrets (Dynamic)
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.AUTO_DEPLOY_TOKEN }}
        script: |
          const repo = await github.rest.repos.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
          });
          const repo_id = repo.data.id;
    
          // dynamic environment name (example: input cluster_name -> ENV_dev7)
          const envName = `ENV_${{ github.event.inputs.cluster_name }}`;
    
          // define only required secrets
          const secretsToSet = {
            KUBECONFIG: process.env.KUBECONFIG_CONTENT, // repo-level secret
            CLUSTER_ENDPOINT: `https://${{ github.event.inputs.vm_host }}:6443`
          };
    
          const sodium = require("tweetsodium");
    
          for (const [secretName, secretValue] of Object.entries(secretsToSet)) {
            if (!secretValue) {
              console.log(`âš ï¸ Skipping ${secretName}, no value provided`);
              continue;
            }
    
            // Get public key for this environment
            const { data: key } = await github.request(
              "GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key",
              {
                repository_id: repo_id,
                environment_name: envName,
              }
            );
    
            // Encrypt secret with sodium
            const messageBytes = Buffer.from(secretValue);
            const keyBytes = Buffer.from(key.key, "base64");
            const encryptedBytes = sodium.seal(messageBytes, keyBytes);
            const encryptedValue = Buffer.from(encryptedBytes).toString("base64");
    
            // Upload secret
            await github.request(
              "PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}",
              {
                repository_id: repo_id,
                environment_name: envName,
                secret_name: secretName,
                encrypted_value: encryptedValue,
                key_id: key.key_id,
              }
            );
    
            console.log(`âœ… Secret ${secretName} set in environment ${envName}`);
          }


      
    - name: Cleanup
      if: always()
      run: |
        rm -f ~/.ssh/vm_key
        rm -f kubeconfig-temp.yaml
        rm -f kind-config.yaml

    - name: Summary
      run: |
        echo "## Kind Cluster Provision Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "âœ… **Cluster Name**: ${{ github.event.inputs.cluster_name }}" >> $GITHUB_STEP_SUMMARY
        echo "âœ… **VM Host**: ${{ github.event.inputs.vm_host }}" >> $GITHUB_STEP_SUMMARY
        echo "âœ… **VM User**: ${{ github.event.inputs.vm_user }}" >> $GITHUB_STEP_SUMMARY
        echo "âœ… **Environment Created**: ENV_${{ github.event.inputs.cluster_name }}" >> $GITHUB_STEP_SUMMARY
        echo "âœ… **Cluster Endpoint**: https://${{ github.event.inputs.vm_host }}:6443" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Environment Variables Set:" >> $GITHUB_STEP_SUMMARY
        echo "- CLUSTER_NAME" >> $GITHUB_STEP_SUMMARY
        echo "- VM_USER" >> $GITHUB_STEP_SUMMARY  
        echo "- VM_HOST" >> $GITHUB_STEP_SUMMARY
        echo "- CLUSTER_ENDPOINT" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Environment Secrets Set:" >> $GITHUB_STEP_SUMMARY
        echo "- VM_KEY" >> $GITHUB_STEP_SUMMARY
        echo "- KUBECONFIG" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ðŸŽ‰ **Kind cluster provisioned successfully!**"
