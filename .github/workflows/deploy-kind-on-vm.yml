name: Provision Kind Cluster on VM

on:
  workflow_dispatch:
    inputs:
      cluster_name:
        description: 'Name of the Kind cluster'
        required: true
        type: string
      vm_user:
        description: 'VM SSH username'
        required: true
        type: string
      vm_key:
        description: 'VM SSH private key'
        required: true
        type: string
      vm_host:
        description: 'VM IP address or hostname'
        required: true
        type: string

jobs:
  provision-kind-cluster:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Validate inputs
      run: |
        if [[ -z "${{ github.event.inputs.cluster_name }}" ]]; then
          echo "Error: cluster_name is required"
          exit 1
        fi
        if [[ -z "${{ github.event.inputs.vm_user }}" ]]; then
          echo "Error: vm_user is required"
          exit 1
        fi
        if [[ -z "${{ github.event.inputs.vm_host }}" ]]; then
          echo "Error: vm_host is required"
          exit 1
        fi
        # Validate cluster name format (alphanumeric and hyphens only)
        if [[ ! "${{ github.event.inputs.cluster_name }}" =~ ^[a-zA-Z0-9-]+$ ]]; then
          echo "Error: cluster_name must contain only alphanumeric characters and hyphens"
          exit 1
        fi

    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        
        # Create SSH key file using base64 to handle special characters
        echo '${{ github.event.inputs.vm_key }}' | base64 -d > ~/.ssh/vm_key 2>/dev/null || {
          # If base64 decode fails, treat as regular text
          cat << 'EOF' > ~/.ssh/vm_key
        ${{ github.event.inputs.vm_key }}
        EOF
        }
        
        # Ensure proper permissions
        chmod 600 ~/.ssh/vm_key
        
        # Debug: Show key format
        echo "SSH key file created. First few lines:"
        head -3 ~/.ssh/vm_key
        echo "Last few lines:"
        tail -3 ~/.ssh/vm_key
        
        # Verify key format
        echo "Verifying SSH key format..."
        if ssh-keygen -l -f ~/.ssh/vm_key; then
          echo "SSH key format is valid"
        else
          echo "SSH key format verification failed. Attempting to fix format..."
          
          # Try to fix common formatting issues
          temp_key=$(cat ~/.ssh/vm_key | tr -d '\r' | tr -s ' ' | sed 's/- /-/g')
          
          # Check if it contains the key headers
          if echo "$temp_key" | grep -q "BEGIN.*PRIVATE KEY"; then
            echo "$temp_key" > ~/.ssh/vm_key
            chmod 600 ~/.ssh/vm_key
            
            # Try verification again
            if ssh-keygen -l -f ~/.ssh/vm_key; then
              echo "SSH key format fixed and verified"
            else
              echo "Error: Could not fix SSH key format"
              echo "Please ensure your SSH private key is properly formatted"
              echo "Expected format example:"
              echo "-----BEGIN RSA PRIVATE KEY-----"
              echo "MIICXAIBAAKBgQC..."
              echo "-----END RSA PRIVATE KEY-----"
              exit 1
            fi
          else
            echo "Error: SSH key does not contain proper headers"
            exit 1
          fi
        fi
        
        # Add host to known_hosts
        ssh-keyscan -H ${{ github.event.inputs.vm_host }} >> ~/.ssh/known_hosts 2>/dev/null || echo "Warning: Could not add host to known_hosts"

    - name: Test SSH connection
      run: |
        echo "Testing SSH connection..."
        ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes ${{ github.event.inputs.vm_user }}@${{ github.event.inputs.vm_host }} "echo 'SSH connection successful'" || (
          echo "SSH connection failed. Debugging..."
          echo "SSH key fingerprint:"
          ssh-keygen -l -f ~/.ssh/vm_key
          echo "Attempting connection with verbose output:"
          ssh -v -i ~/.ssh/vm_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 ${{ github.event.inputs.vm_user }}@${{ github.event.inputs.vm_host }} "echo 'test'" 2>&1 | head -20
          exit 1
        )

    - name: Install dependencies on VM
      run: |
        ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 ${{ github.event.inputs.vm_user }}@${{ github.event.inputs.vm_host }} << 'EOF'
          set -e
          
          echo "Updating system packages..."
          sudo apt-get update -y
          
          # Install Docker if not already installed
          if ! command -v docker &> /dev/null; then
            echo "Installing Docker..."
            # Remove any old Docker packages
            sudo apt-get remove -y docker docker-engine docker.io containerd runc || true
            
            # Install prerequisites
            sudo apt-get install -y \
              ca-certificates \
              curl \
              gnupg \
              lsb-release
            
            # Add Docker's official GPG key
            sudo mkdir -p /etc/apt/keyrings
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            
            # Set up repository
            echo \
              "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
              $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            
            # Install Docker Engine
            sudo apt-get update -y
            sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
            
            # Add user to docker group
            sudo usermod -aG docker $USER
            
            # Enable and start Docker
            sudo systemctl enable docker
            sudo systemctl start docker
            
            # Wait for Docker to be ready
            sleep 5
            sudo docker version
          else
            echo "Docker is already installed"
            docker --version
          fi
          
          # Install kubectl if not already installed
          if ! command -v kubectl &> /dev/null; then
            echo "Installing kubectl..."
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
          else
            echo "kubectl is already installed"
          fi
          kubectl version --client
          
          # Install Kind if not already installed
          if ! command -v kind &> /dev/null; then
            echo "Installing Kind..."
            curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
            chmod +x ./kind
            sudo mv ./kind /usr/local/bin/kind
          else
            echo "Kind is already installed"
          fi
          kind version
          
          echo "All dependencies installed successfully"
        EOF

    - name: Create Kind cluster configuration
      run: |
        cat > kind-config.yaml << EOF
        kind: Cluster
        apiVersion: kind.x-k8s.io/v1alpha4
        name: ${{ github.event.inputs.cluster_name }}
        networking:
          apiServerAddress: "0.0.0.0"
          apiServerPort: 6443
        nodes:
        - role: control-plane
          kubeadmConfigPatches:
          - |
            kind: InitConfiguration
            nodeRegistration:
              kubeletExtraArgs:
                node-labels: "ingress-ready=true"
          - |
            kind: ClusterConfiguration
            apiServer:
              certSANs:
              - ${{ github.event.inputs.vm_host }}
              - "localhost"
              - "127.0.0.1"
          extraPortMappings:
          - containerPort: 80
            hostPort: 80
            protocol: TCP
          - containerPort: 443
            hostPort: 443
            protocol: TCP
          - containerPort: 6443
            hostPort: 16443
            protocol: TCP
        EOF

    - name: Copy Kind config to VM and create cluster
      run: |
        # Copy kind config to VM
        scp -i ~/.ssh/vm_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 kind-config.yaml ${{ github.event.inputs.vm_user }}@${{ github.event.inputs.vm_host }}:~/
        
        # Create Kind cluster on VM
        ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 ${{ github.event.inputs.vm_user }}@${{ github.event.inputs.vm_host }} << 'EOF'
          set -e
          
          # Check if cluster already exists
          if kind get clusters 2>/dev/null | grep -q "^${{ github.event.inputs.cluster_name }}$"; then
            echo "Cluster ${{ github.event.inputs.cluster_name }} already exists, deleting it first..."
            kind delete cluster --name ${{ github.event.inputs.cluster_name }} || true
            sleep 10
          fi
          
          echo "Creating Kind cluster: ${{ github.event.inputs.cluster_name }}"
          
          # Use newgrp to ensure docker group membership is active
          newgrp docker << 'DOCKER_EOF'
          kind create cluster --config kind-config.yaml --wait 300s
          echo "Cluster created successfully"
          kubectl cluster-info --context kind-${{ github.event.inputs.cluster_name }}
        DOCKER_EOF
        EOF

    - name: Get kubeconfig from VM
      run: |
        # Get kubeconfig from VM
        ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 ${{ github.event.inputs.vm_user }}@${{ github.event.inputs.vm_host }} "newgrp docker << 'DOCKER_EOF'
        kind get kubeconfig --name ${{ github.event.inputs.cluster_name }}
        DOCKER_EOF" > kubeconfig-temp.yaml


        # Modify kubeconfig to use VM's external IP
        sed -i "s/127.0.0.1/${{ github.event.inputs.vm_host }}/g" kubeconfig-temp.yaml
        sed -i "s/0.0.0.0/${{ github.event.inputs.vm_host }}/g" kubeconfig-temp.yaml
        
        echo "Modified kubeconfig to use external VM IP"
        echo "Kubeconfig content:"
        cat kubeconfig-temp.yaml

    - name: Test cluster connectivity
      run: |
        export KUBECONFIG=./kubeconfig-temp.yaml
        kubectl cluster-info
        kubectl get nodes
        echo "Cluster is accessible from external network"

    - name: Create GitHub Environment
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const envName = `ENV_${{ github.event.inputs.cluster_name }}`;
          
          try {
            // Try to get existing environment
            await github.rest.repos.getEnvironment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              environment_name: envName
            });
            console.log(`Environment ${envName} already exists`);
          } catch (error) {
            if (error.status === 404) {
              // Create new environment
              await github.rest.repos.createOrUpdateEnvironment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                environment_name: envName,
                wait_timer: 0,
                prevent_self_review: false,
                reviewers: null,
                deployment_branch_policy: null
              });
              console.log(`Created environment: ${envName}`);
            } else {
              throw error;
            }
          }

    - name: Set environment variables and secrets
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const fs = require('fs');
          const envName = `ENV_${{ github.event.inputs.cluster_name }}`;
          
          // Read kubeconfig content
          const kubeconfigContent = fs.readFileSync('./kubeconfig-temp.yaml', 'utf8');
          
          // Function to create/update environment secret
          async function createSecret(secretName, secretValue) {
            try {
              // Get public key for encryption
              const publicKeyResponse = await github.rest.actions.getEnvironmentPublicKey({
                repository_id: context.payload.repository.id,
                environment_name: envName
              });
              
              // Encrypt the secret value
              const sodium = require('tweetsodium');
              const key = publicKeyResponse.data.key;
              const keyBytes = Buffer.from(key, 'base64');
              const messageBytes = Buffer.from(secretValue);
              const encryptedBytes = sodium.seal(messageBytes, keyBytes);
              const encrypted = Buffer.from(encryptedBytes).toString('base64');
              
              // Create or update the secret
              await github.rest.actions.createOrUpdateEnvironmentSecret({
                repository_id: context.payload.repository.id,
                environment_name: envName,
                secret_name: secretName,
                encrypted_value: encrypted,
                key_id: publicKeyResponse.data.key_id
              });
              
              console.log(`Set secret: ${secretName}`);
            } catch (error) {
              console.error(`Failed to set secret ${secretName}:`, error.message);
              throw error;
            }
          }
          
          // Function to create/update environment variable
          async function createVariable(variableName, variableValue) {
            try {
              await github.rest.actions.createEnvironmentVariable({
                repository_id: context.payload.repository.id,
                environment_name: envName,
                name: variableName,
                value: variableValue
              });
              console.log(`Set variable: ${variableName}`);
            } catch (error) {
              if (error.status === 409) {
                // Variable exists, update it
                await github.rest.actions.updateEnvironmentVariable({
                  repository_id: context.payload.repository.id,
                  environment_name: envName,
                  name: variableName,
                  value: variableValue
                });
                console.log(`Updated variable: ${variableName}`);
              } else {
                console.error(`Failed to set variable ${variableName}:`, error.message);
                throw error;
              }
            }
          }
          
          // Set secrets (sensitive data)
          await createSecret('VM_KEY', '${{ github.event.inputs.vm_key }}');
          await createSecret('KUBECONFIG', kubeconfigContent);
          
          // Set variables (non-sensitive data)
          await createVariable('CLUSTER_NAME', '${{ github.event.inputs.cluster_name }}');
          await createVariable('VM_USER', '${{ github.event.inputs.vm_user }}');
          await createVariable('VM_HOST', '${{ github.event.inputs.vm_host }}');
          await createVariable('CLUSTER_ENDPOINT', `https://${{ github.event.inputs.vm_host }}:6443`);

    - name: Install tweetsodium dependency
      run: npm install tweetsodium
      
    - name: Cleanup
      if: always()
      run: |
        rm -f ~/.ssh/vm_key
        rm -f kubeconfig-temp.yaml
        rm -f kind-config.yaml

    - name: Summary
      run: |
        echo "## Kind Cluster Provision Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "âœ… **Cluster Name**: ${{ github.event.inputs.cluster_name }}" >> $GITHUB_STEP_SUMMARY
        echo "âœ… **VM Host**: ${{ github.event.inputs.vm_host }}" >> $GITHUB_STEP_SUMMARY
        echo "âœ… **VM User**: ${{ github.event.inputs.vm_user }}" >> $GITHUB_STEP_SUMMARY
        echo "âœ… **Environment Created**: ENV_${{ github.event.inputs.cluster_name }}" >> $GITHUB_STEP_SUMMARY
        echo "âœ… **Cluster Endpoint**: https://${{ github.event.inputs.vm_host }}:6443" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Environment Variables Set:" >> $GITHUB_STEP_SUMMARY
        echo "- CLUSTER_NAME" >> $GITHUB_STEP_SUMMARY
        echo "- VM_USER" >> $GITHUB_STEP_SUMMARY  
        echo "- VM_HOST" >> $GITHUB_STEP_SUMMARY
        echo "- CLUSTER_ENDPOINT" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Environment Secrets Set:" >> $GITHUB_STEP_SUMMARY
        echo "- VM_KEY" >> $GITHUB_STEP_SUMMARY
        echo "- KUBECONFIG" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ðŸŽ‰ **Kind cluster provisioned successfully!**"
